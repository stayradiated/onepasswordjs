// Generated by CoffeeScript 1.6.2
/**
 * A collection of cryptographic functions.
 * The important ones (AES, SHA, HMAC ...) are all wrappers for the openssl
 * library built into Node.
*/


(function() {
  var BLOCKSIZE, Crypto, nodeCrypto;

  nodeCrypto = require('crypto');

  BLOCKSIZE = 16;

  Crypto = {
    /**
     * Encrypt data using AES256 in CBC mode.
     * - plaintext {Buffer} : The data to encrypt.
     * - key {String|Buffer} : The key to encrypt with.
     * - iv {String|Buffer} : The initialization vector.
     * - [encoding] {string} : The format to return the encrypted data in.
     * > buffer
    */

    encrypt: function(plaintext, key, iv, encoding) {
      var buffer, cipher;

      iv = this.toBuffer(iv);
      key = this.toBuffer(key);
      cipher = nodeCrypto.createCipheriv('aes-256-cbc', key, iv);
      cipher.setAutoPadding(false);
      buffer = this.concat([cipher.update(plaintext), cipher.final()]);
      if (encoding != null) {
        return buffer.toString(encoding);
      }
      return buffer;
    },
    /**
     * Decrypt encrypted data using AES256 in CBC mode
     * - ciphertext {String|Buffer} : The data to decipher. Length must be a
     *   multiple of the blocksize.
     * - key {String|Buffer} : The key to decipher with.
     * - iv {String|Buffer} : The initialization vector.
     * - [encoding] {String} : The format to return the decrypted contents in.
     * > buffer
    */

    decrypt: function(ciphertext, key, iv, encoding) {
      var buffer, cipher;

      iv = this.toBuffer(iv);
      key = this.toBuffer(key);
      ciphertext = this.toBuffer(ciphertext);
      cipher = nodeCrypto.createDecipheriv('aes-256-cbc', key, iv);
      cipher.setAutoPadding(false);
      buffer = this.concat([cipher.update(ciphertext), cipher.final()]);
      if (encoding != null) {
        return buffer.toString(encoding);
      }
      return buffer;
    },
    /**
     * Generate keys from password using PKDF2-HMAC-SHA512.
     * - password {String|Buffer} : The password.
     * - salt {String|Buffer} : The salt.
     * - [iterations=10000] {Number} : The numbers of iterations.
     * - [keysize=512] {Number} : The SHA algorithm to use.
     * > string
    */

    pbkdf2: require('./crypto_pbkdf2'),
    /**
     * Cryptographically hash data using HMAC.
     * - data {String|Buffer} : The data to be hashed.
     * - key {String|Buffer} : The key to use with HMAC.
     * - keysize {Number} : The type of hash to use, e.g. 256 or 512.
     * - [encoding] {String} : Data encoding to return as. If left unspecified,
     *   it will return as a buffer.
     * > buffer
    */

    hmac: function(data, key, keysize, encoding) {
      var hmac, mode;

      data = this.toBuffer(data);
      key = this.toBuffer(key);
      mode = 'sha' + keysize;
      hmac = nodeCrypto.createHmac(mode, key);
      hmac.update(data);
      if (encoding != null) {
        return hmac.digest(encoding);
      }
      return hmac.digest();
    },
    /**
     * Create a hash digest of data.
     * - data {String|Buffer} : The data to hash.
     * - keysize {Number} : The type of hash to use, e.g. 256 or 512.
     * - [encoding] {String} : Data encoding to return as. If left unspecified,
     *   it will return as a buffer.
     * > buffer
    */

    hash: function(data, keysize, encoding) {
      var hash, mode;

      data = this.toBuffer(data);
      mode = 'sha' + keysize;
      hash = nodeCrypto.createHash(mode);
      hash.update(data);
      if (encoding != null) {
        return hash.digest(encoding);
      }
      return hash.digest();
    },
    /**
     * Prepend padding to data to make it fill the blocksize.
     * - data {Buffer} : The data to pad.
     * > buffer
    */

    pad: function(data) {
      var padding, paddingLength;

      paddingLength = BLOCKSIZE - (data.length % BLOCKSIZE);
      padding = this.randomBytes(paddingLength);
      return Buffer.concat([padding, data]);
    },
    /**
     * Remove padding from text.
     * - plaintextLength {Number} : The length of the plaintext in bytes.
     * - data {String|Buffer} : The data to remove the padding from. Can be a
     *   hex string or a buffer.
     * > string
    */

    unpad: function(plaintextLength, data) {
      data = this.toHex(data);
      plaintextLength *= 2;
      return data.slice(-plaintextLength);
    },
    /**
     * Generates cryptographically strong pseudo-random data.
     * - length {Number} : How many bytes of data you need.
     * > buffer
    */

    randomBytes: function(length) {
      return nodeCrypto.randomBytes(length);
    },
    /**
     * Generate a cryptographically strong pseudo-random number.
     * Very similar to Math.random() except it's more random.
     * > float - between 0 and 1
    */

    randomValue: function() {
      var bytes, decimal, hex;

      bytes = this.randomBytes(4);
      hex = bytes.toString('hex');
      decimal = parseInt(hex, 16);
      return decimal * Math.pow(2, -32);
    },
    /**
     * Convert data to a Buffer
     * - data {String|Buffer} : The string to be converted.
     * - [encoding=hex] {String} : The format of the data to convert from.
     * > buffer
    */

    toBuffer: function(data, encoding) {
      if (encoding == null) {
        encoding = 'hex';
      }
      if (data instanceof Buffer) {
        return data;
      }
      return new Buffer(data, encoding);
    },
    /**
     * Convert data to hex.
     * - data {String|Buffer} : The data to be converted.
     * > string
    */

    toHex: function(data) {
      if (data instanceof Buffer) {
        return data.toString('hex');
      }
      if (typeof data === 'string') {
        return data;
      }
      throw new Error('Input is not the correct type');
    },
    /**
     * Convert base64 to Buffer.
     * - data {String} : A base64 encoded string.
     * > buffer
    */

    fromBase64: function(data) {
      return new Buffer(data, 'base64');
    },
    /**
     * Join an array of buffers together.
     * - buffers {Array} : An array of buffers.
     * > buffer
    */

    concat: function(buffers) {
      return Buffer.concat(buffers);
    },
    /**
     * Parse a litte endian number. Original JS version by Jim Rogers.
     * http://www.jimandkatrin.com/CodeBlog/post/Parse-a-little-endian.aspx
     * - hex {String} : The little endian number.
     * > {Number} - the little endian converted to a number.
    */

    parseLittleEndian: function(hex) {
      var i, len, pow, result;

      result = 0;
      pow = 0;
      i = 0;
      len = hex.length - 1;
      while (i < len) {
        result += parseInt(hex.slice(i++, +(i++) + 1 || 9e9), 16) * Math.pow(2, pow);
        pow += 8;
      }
      return result;
    },
    /**
     * Convert an integer into a little endian.
     * - number {Number} number The integer you want to convert.
     * - [pad=true] {Boolean} : Pad the little endian with zeroes.
     * > string
    */

    stringifyLittleEndian: function(number, pad) {
      var endian, i, multiplier, padding, power, remainder, value, _i;

      if (pad == null) {
        pad = true;
      }
      power = Math.floor((Math.log(number) / Math.LN2) / 8) * 8;
      multiplier = Math.pow(2, power);
      value = Math.floor(number / multiplier);
      remainder = number % multiplier;
      endian = "";
      if (remainder > 255) {
        endian += this.stringifyLittleEndian(remainder, false);
      } else if (power !== 0) {
        endian += this.dec2hex(remainder);
      }
      endian += this.dec2hex(value);
      if (pad) {
        padding = 16 - endian.length;
        for (i = _i = 0; _i < padding; i = _i += 1) {
          endian += "0";
        }
      }
      return endian;
    },
    /**
     * Turn a decimal into a hexadecimal.
     * - dec {Number} : The decimal.
     * > string
    */

    dec2hex: function(dec) {
      var hex;

      hex = dec.toString(16);
      if (hex.length < 2) {
        hex = "0" + hex;
      }
      return hex;
    },
    /**
     * Convert a binary string into a hex string.
     * - binary {String} : The binary encoded string.
     * > string
    */

    bin2hex: function(binary) {
      var char, hex, _i, _len;

      hex = "";
      for (_i = 0, _len = binary.length; _i < _len; _i++) {
        char = binary[_i];
        hex += char.charCodeAt(0).toString(16).replace(/^([\dA-F])$/i, "0$1");
      }
      return hex;
    },
    /**
     * Generate a uuid.
     * - param {Number} [length=32] The length of the UUID.
     * > string
    */

    generateUuid: function(length) {
      if (length == null) {
        length = 32;
      }
      length /= 2;
      return this.randomBytes(length).toString('hex').toUpperCase(0);
    }
  };

  module.exports = Crypto;

}).call(this);
