// Generated by CoffeeScript 1.6.3
/**
 * Read and write 1Password 4 Cloud Keychain files. Based on the documentation
 * at http://learn.agilebits.com/1Password4/Security/keychain-design.html
 * and https://github.com/Roguelazer/onepasswordpy
*/


(function() {
  var BAND_PREFIX, BAND_SUFFIX, Crypto, EventEmitter, Item, Keychain, Opdata, PROFILE_PREFIX, PROFILE_SUFFIX, fs,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  fs = require('fs');

  EventEmitter = require('events').EventEmitter;

  Crypto = require('./crypto');

  Opdata = require('./opdata');

  Item = require('./item');

  BAND_PREFIX = 'ld(';

  BAND_SUFFIX = ');';

  PROFILE_PREFIX = 'var profile=';

  PROFILE_SUFFIX = ';';

  Keychain = (function() {
    /**
     * Create a new keychain
     * - password  {string} : The master password for the keychain.
     * - [settings] {object} : Extra options for the keychain, such as the hint
     *   and number of iterations
     * > Keychain - a new Keychain object
    */

    Keychain.create = function(password, settings) {
      var currentTime, key, keychain, keys, options, raw, superKey, _i, _len;
      if (settings == null) {
        settings = {};
      }
      currentTime = Math.floor(Date.now() / 1000);
      options = {
        uuid: Crypto.generateUuid(),
        salt: Crypto.randomBytes(16),
        createdAt: currentTime,
        updatedAt: currentTime,
        iterations: 10000,
        profileName: 'default',
        passwordHint: '',
        lastUpdatedBy: 'Dropbox'
      };
      for (_i = 0, _len = options.length; _i < _len; _i++) {
        key = options[_i];
        if (settings.hasOwnProperty(key)) {
          options[key] = settings[key];
        }
      }
      keychain = new Keychain(options);
      raw = {
        master: Crypto.randomBytes(256),
        overview: Crypto.randomBytes(64)
      };
      superKey = keychain._deriveKeys(password);
      keychain.encrypted = {
        masterKey: superKey.encrypt('profileKey', raw.master),
        overviewKey: superKey.encrypt('profileKey', raw.overview)
      };
      keys = {
        master: Crypto.hash(raw.master, 512),
        overview: Crypto.hash(raw.overview, 512)
      };
      keychain.master = new Opdata(keys.master.slice(0, 32), keys.master.slice(32));
      keychain.overview = new Opdata(keys.overview.slice(0, 32), keys.overview.slice(32));
      return keychain;
    };

    /**
     * Constructs a new Keychain
     * - [attrs] {object} : Load items
    */


    function Keychain(attrs) {
      this._autolock = __bind(this._autolock, this);
      this.AUTOLOCK_LENGTH = 1 * 60 * 1000;
      this.profileName = 'default';
      this.items = {};
      this.unlocked = false;
      this.event = new EventEmitter();
      if (attrs) {
        this.loadAttrs(attrs);
      }
    }

    /**
     * Easy way to load data into a keychain
     * - {object} attrs The attributes you want to load
     * > this - so it can be chained
    */


    Keychain.prototype.loadAttrs = function(attrs) {
      var attr, key;
      for (key in attrs) {
        attr = attrs[key];
        this[key] = attr;
      }
      return this;
    };

    /**
     * Derive the 'super' keys from password using PBKDF2
     * - {string} password The master password.
     * > Opdata - the derived keys.
    */


    Keychain.prototype._deriveKeys = function(password) {
      var keys;
      keys = Crypto.pbkdf2(password, this.salt, this.iterations);
      return new Opdata(keys.slice(0, 32), keys.slice(32));
    };

    /*
     * Load data from a .cloudKeychain folder
     * - filepath {string} : The filepath of the .cloudKeychain file
     * - [callback] {function} : Called when the keychain has loaded
     * ! if profile.js can't be found
     * > this
    */


    Keychain.prototype.load = function(keychainPath, callback) {
      var _this = this;
      this.keychainPath = keychainPath;
      if (callback == null) {
        callback = function() {};
      }
      this.profileFolder = this.keychainPath + '/' + this.profileName;
      fs.readdir(this.profileFolder, function(err, folderContents) {
        var attachments, bands, filename, folder, folders, profile, _i, _len;
        if (err != null) {
          callback(err);
        }
        profile = null;
        folder = null;
        bands = [];
        attachments = [];
        for (_i = 0, _len = folderContents.length; _i < _len; _i++) {
          filename = folderContents[_i];
          if (filename === 'profile.js') {
            profile = _this.profileFolder + '/profile.js';
          } else if (filename === 'folders.js') {
            folders = _this.profileFolder + '/folders.js';
          } else if (filename.match(/^band_[0-9A-F]\.js$/)) {
            bands.push(_this.profileFolder + '/' + filename);
          } else if (filename.match(/^[0-9A-F]{32}_[0-9A-F]{32}\.attachment$/)) {
            attachments.push(filename);
          }
        }
        if (profile != null) {
          _this.loadProfile(profile);
        } else {
          callback(new Error('Couldn\'t find profile.js'));
        }
        if (folders != null) {
          _this.loadFolders(folders);
        }
        if (bands.length > 0) {
          _this.loadBands(bands);
        }
        if (attachments.length > 0) {
          _this.loadAttachment(attachments);
        }
        return callback(null);
      });
      return this;
    };

    /**
     * Load data from profile.js into keychain.
     * - filepath {string} : The path to the profile.js file.
     * - [rawData=false] {boolean} : If set to true, 'filepath' will be
     *   considered the actual profile data to load from.
     * > this
    */


    Keychain.prototype.loadProfile = function(filepath, rawData) {
      var data, json, profile;
      if (rawData) {
        data = filepath;
      } else {
        data = fs.readFileSync(filepath).toString();
      }
      json = data.slice(PROFILE_PREFIX.length, -PROFILE_SUFFIX.length);
      profile = JSON.parse(json);
      this.loadAttrs({
        uuid: profile.uuid,
        salt: Crypto.fromBase64(profile.salt),
        createdAt: profile.createdAt,
        updatedAt: profile.updatedAt,
        iterations: profile.iterations,
        profileName: profile.profileName,
        passwordHint: profile.passwordHint,
        lastUpdatedBy: profile.lastUpdatedBy
      });
      this.encrypted = {
        masterKey: Crypto.fromBase64(profile.masterKey),
        overviewKey: Crypto.fromBase64(profile.overviewKey)
      };
      return this;
    };

    /**
     * Load folders
     * - filepath {string} : The path to the folders.js file.
    */


    Keychain.prototype.loadFolders = function(filepath) {};

    /**
     * This loads the item data from a band file into the keychain.
     * - bands {array} : An array of filepaths to each band file
     * > this
    */


    Keychain.prototype.loadBands = function(bands) {
      var band, filepath, item, uuid, _i, _len;
      for (_i = 0, _len = bands.length; _i < _len; _i++) {
        filepath = bands[_i];
        band = fs.readFileSync(filepath).toString('utf8');
        band = band.slice(BAND_PREFIX.length, -BAND_SUFFIX.length);
        band = JSON.parse(band);
        for (uuid in band) {
          item = band[uuid];
          this.addItem(item);
        }
      }
      return this;
    };

    /**
     * Load attachments
     * - attachments {Array} : An array of filepaths to each attachment file
    */


    Keychain.prototype.loadAttachment = function(attachments) {};

    /**
     * Change the keychain master password. Since the derived keys and raw key
     * data aren't stored, the current password must be supplied to decrypt this
     * data again. Though slower, this is more secure than keeping this data in
     * memory.
     * - currentPassword {string} : The current master password.
     * - newPassword {string} : The password to change to.
     * > this
    */


    Keychain.prototype.changePassword = function(currentPassword, newPassword) {
      var currentKey, masterKey, newKey, overviewKey;
      currentKey = this._deriveKeys(currentPassword);
      masterKey = currentKey.decrypt('buffer', this.encrypted.masterKey);
      overviewKey = currentKey.decrypt('buffer', this.encrypted.overviewKey);
      newKey = this._deriveKeys(newPassword);
      this.encrypted.masterKey = newKey.encrypt('profileKey', masterKey);
      this.encrypted.overviewKey = newKey.encrypt('profileKey', overviewKey);
      return this;
    };

    /**
     * Runs the master password through PBKDF2 to derive the super keys, and then
     * decrypt the masterKey and overviewKey. The master password and super keys
     * are then forgotten as they are no longer needed and keeping them in memory
     * will only be a security risk.
     * Use @unlocked to check if it was the right password.
     * - password {string} : The master password to unlock the keychain with.
     * > this
    */


    Keychain.prototype.unlock = function(password) {
      var master, overview, profileKey,
        _this = this;
      if (this.unlocked === true) {
        console.log('Keychain already unlocked...');
        return this;
      }
      profileKey = this._deriveKeys(password);
      master = profileKey.decrypt('profileKey', this.encrypted.masterKey);
      if (!master.length) {
        console.error('Could not decrypt master key');
        this.unlocked = false;
        return this;
      }
      overview = profileKey.decrypt('profileKey', this.encrypted.overviewKey);
      if (!overview.length) {
        console.error('Could not decrypt overview key');
        this.unlocked = false;
        return this;
      }
      this.master = new Opdata(master[0], master[1]);
      this.overview = new Opdata(overview[0], overview[1]);
      this.eachItem(function(item) {
        return item.unlock('overview');
      });
      this.unlocked = true;
      this.event.emit('unlock');
      this.rescheduleAutoLock();
      setTimeout((function() {
        return _this._autolock();
      }), 1000);
      return this;
    };

    /**
     * Lock the keychain. This discards all currently decrypted keys, overview
     * data and any decrypted item details.
     * - _autolock {Boolean} : Whether the keychain was locked automatically.
     * > this
    */


    Keychain.prototype.lock = function(_autolock) {
      this.event.emit('lock:before', _autolock);
      this["super"] = void 0;
      this.master = void 0;
      this.overview = void 0;
      this.eachItem(function(item) {
        return item.lock('all');
      });
      this.unlocked = false;
      this.event.emit('lock:after', _autolock);
      return this;
    };

    /**
     * Reschedule when the keychain is locked. Should be called only when the
     * user performs an important action, such as unlocking the keychain,
     * selecting an item or copying a password, so that it doesn't lock when
     * they are using it.
    */


    Keychain.prototype.rescheduleAutoLock = function() {
      return this.autoLockTime = Date.now() + this.AUTOLOCK_LENGTH;
    };

    /**
     * This is run every second, to check to see if the timer has expired. If it
     * has it then locks the keychain.
    */


    Keychain.prototype._autolock = function() {
      var now;
      if (!this.unlocked) {
        return;
      }
      now = Date.now();
      if (now < this.autoLockTime) {
        setTimeout(this._autolock, 1000);
        return;
      }
      return this.lock(true);
    };

    /**
     * Expose Item.create so you only have to include this one file
     * - data {Object} : Item data.
     * > object - An item instance.
    */


    Keychain.prototype.createItem = function(data) {
      return Item.create(this, data);
    };

    /**
     * Add an item to the keychain
     * - item {Object} : The item to add to the keychain
     * > this
    */


    Keychain.prototype.addItem = function(item) {
      if (!(item instanceof Item)) {
        item = new Item(this).load(item);
      }
      this.items[item.uuid] = item;
      return this;
    };

    /**
     * This returns an item with the matching UUID
     * - uuid {string} : The UUID to find the Item of
     * > item
    */


    Keychain.prototype.getItem = function(uuid) {
      return this.items[uuid];
    };

    /**
     * Search through all items, does not include deleted items
     * - query {string} - the search query
     * > array - items that match the query
    */


    Keychain.prototype.findItems = function(query) {
      var item, items, uuid, _ref;
      items = [];
      _ref = this.items;
      for (uuid in _ref) {
        item = _ref[uuid];
        if (item.trashed) {
          continue;
        }
        if (item.match(query) === null) {
          continue;
        }
        items.push(item);
      }
      return items;
    };

    /**
     * Loop through all the items in the keychain, and pass each one to a
     * function.
     * - fn  {Function} : The function to pass each item to
     * > this
    */


    Keychain.prototype.eachItem = function(fn) {
      var item, uuid, _ref;
      _ref = this.items;
      for (uuid in _ref) {
        item = _ref[uuid];
        fn(item);
      }
      return this;
    };

    /**
     * Generate the profile.js file
     * > string - the profile.js file contents as json
    */


    Keychain.prototype.exportProfile = function() {
      var data;
      data = {
        lastUpdatedBy: this.lastUpdatedBy,
        updatedAt: this.updatedAt,
        profileName: this.profileName,
        salt: this.salt.toString('base64'),
        passwordHint: this.passwordHint,
        masterKey: this.encrypted.masterKey.toString('base64'),
        iterations: this.iterations,
        uuid: this.uuid,
        overviewKey: this.encrypted.overviewKey.toString('base64'),
        createdAt: this.createdAt
      };
      return PROFILE_PREFIX + JSON.stringify(data) + PROFILE_SUFFIX;
    };

    /**
     * This exports all the items currently in the keychain into band files.
     * > object - the band files as { filename: contents }
    */


    Keychain.prototype.exportBands = function() {
      var bands, data, files, id, item, items, uuid, _i, _len, _ref;
      bands = {};
      _ref = this.items;
      for (uuid in _ref) {
        item = _ref[uuid];
        id = uuid.slice(0, 1);
        if (bands[id] == null) {
          bands[id] = [];
        }
        bands[id].push(item);
      }
      files = {};
      for (id in bands) {
        items = bands[id];
        data = {};
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          data[item.uuid] = item.toJSON();
        }
        data = BAND_PREFIX + JSON.stringify(data, null, 2) + BAND_SUFFIX;
        files["band_" + id + ".js"] = data;
      }
      return files;
    };

    return Keychain;

  })();

  module.exports = Keychain;

}).call(this);
